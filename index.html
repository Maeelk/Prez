<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LEGO Studio 3D</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: rgba(17, 24, 39, 0.9);
      --panel-2: rgba(30, 41, 59, 0.86);
      --accent: #60a5fa;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --danger: #ef4444;
      --ok: #22c55e;
      --cell: #1f2937;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    * { box-sizing: border-box; user-select: none; }
    body { margin: 0; background: radial-gradient(circle at 20% 10%, #1e293b, #020617 70%); color: var(--text); overflow: hidden; }
    #app { position: fixed; inset: 0; }
    #ui {
      position: fixed; inset: 0; pointer-events: none;
      display: grid; grid-template-columns: 360px 1fr;
    }
    #panel {
      pointer-events: auto; height: 100%; width: 360px;
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      backdrop-filter: blur(8px); border-right: 1px solid rgba(255,255,255,.08);
      padding: 10px; overflow: auto; transition: transform .25s ease;
    }
    #panel.collapsed { transform: translateX(-320px); }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .title { font-size: 18px; font-weight: 700; letter-spacing: .4px; margin: 2px 0 8px; }
    .sub { font-size: 12px; color: var(--muted); margin-bottom: 8px; }
    .group { border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 10px; margin-bottom: 10px; background: rgba(2,6,23,.35); }
    button, select, input[type="color"], input[type="text"], textarea {
      background: #111827; color: var(--text); border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px; padding: 6px 8px; font-size: 12px;
    }
    button { cursor: pointer; transition: transform .08s ease, background .2s; }
    button:hover { background: #1f2937; }
    button:active { transform: translateY(1px) scale(.98); }
    button.primary { background: linear-gradient(180deg, #3b82f6, #1d4ed8); border-color: rgba(96,165,250,.7); }
    button.danger { background: linear-gradient(180deg, #f87171, #dc2626); }
    button.ghost { background: rgba(2,6,23,.5); }
    label.toggle { display:flex; align-items:center; gap:6px; font-size:12px; color:#cbd5e1; }
    #partGrid, #colorGrid {
      display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;
      max-height: 230px; overflow: auto; padding-right: 3px;
    }
    .part-btn {
      padding: 6px; border-radius: 10px; background: #0f172a; border:1px solid rgba(255,255,255,.12);
      font-size: 11px; text-align:center; cursor: grab;
    }
    .part-btn.active { outline: 2px solid var(--accent); }
    .swatch {
      width: 100%; height: 22px; border-radius: 8px; border: 1px solid rgba(255,255,255,.25); cursor:pointer;
    }
    .swatch.active { outline: 2px solid #fff; }
    #togglePanel {
      position: fixed; top: 12px; left: 12px; z-index: 4; pointer-events: auto;
      border-radius: 999px; width: 34px; height: 34px;
    }
    #hint {
      position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%);
      pointer-events:none; background: rgba(2,6,23,.65); border:1px solid rgba(255,255,255,.12);
      border-radius: 999px; padding: 7px 14px; color:#cbd5e1; font-size: 12px;
    }
    #selectionBox {
      position: fixed; border: 1px dashed #93c5fd; background: rgba(59,130,246,.14);
      display: none; pointer-events:none; z-index:5;
    }
    #ioArea { width: 100%; min-height: 80px; }
    .tiny { font-size: 11px; color: var(--muted); }
  </style>
</head>
<body>
  <div id="app"></div>
  <button id="togglePanel">☰</button>
  <div id="ui">
    <aside id="panel">
      <div class="title">✨ LEGO Studio 3D</div>
      <div class="sub">Click place · Drag palette · Q/E rotate · Shift-drag box select · Right-drag camera</div>

      <div class="group">
        <div class="row" style="justify-content:space-between;">
          <b>Parts Library</b>
          <select id="category"></select>
        </div>
        <div id="partGrid"></div>
      </div>

      <div class="group">
        <div class="row" style="justify-content:space-between;"><b>Colors</b><input id="customColor" type="color" value="#d9a066" /></div>
        <div id="colorGrid"></div>
      </div>

      <div class="group">
        <b>Scene</b>
        <div class="row" style="margin-top:8px;">
          <select id="baseplateSize">
            <option>16x16</option><option selected>32x32</option><option>48x48</option><option>64x64</option>
          </select>
          <button id="applyBaseplate">Baseplate</button>
          <button id="clearScene" class="danger">Clear</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <label class="toggle"><input id="gridSnap" type="checkbox" checked />Grid snap</label>
          <label class="toggle"><input id="angleSnap" type="checkbox" checked />Angle snap</label>
          <label class="toggle"><input id="supportCheck" type="checkbox" checked />Stud support</label>
        </div>
      </div>

      <div class="group">
        <b>Edit</b>
        <div class="row" style="margin-top:8px;">
          <button id="undo">Undo</button><button id="redo">Redo</button>
          <button id="copy">Copy</button><button id="paste">Paste</button><button id="delete">Delete</button>
        </div>
      </div>

      <div class="group">
        <b>Templates</b>
        <div class="row" style="margin-top:8px;">
          <button class="tpl" data-template="car">Car</button>
          <button class="tpl" data-template="castle">Castle</button>
          <button class="tpl" data-template="spaceship">Spaceship</button>
          <button class="tpl" data-template="robot">Robot</button>
        </div>
      </div>

      <div class="group">
        <b>Save / Load</b>
        <div class="row" style="margin-top:8px;">
          <button id="saveLocal" class="primary">Save</button>
          <select id="saveSlots"><option value="">(slot)</option></select>
          <button id="loadLocal">Load</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <button id="exportJson">Export JSON</button>
          <button id="importJson">Import JSON</button>
        </div>
        <textarea id="ioArea" placeholder="JSON import/export appears here"></textarea>
        <div class="tiny">Saves include auto-thumbnail preview in localStorage.</div>
      </div>
    </aside>
  </div>
  <div id="selectionBox"></div>
  <div id="hint">Ready</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/controls/OrbitControls.js';

    const STUD = 1;
    const PLATE = 0.4;
    const BASE_HEIGHT = 0.3;
    const app = document.getElementById('app');
    const hint = document.getElementById('hint');

    const colors = [
      '#ffffff','#cfd2d6','#6d6e71','#111111','#d91f26','#9c1116','#0055bf','#5a93db','#237841','#7ed321',
      '#f2cd37','#f7b500','#f8bbd0','#c870a0','#7b4bb7','#4b9fca','#dbac34','#c98b2e','#d9a066','#8a5a2b',
      '#ff7f50','#74c6ad','#b8d8f8','#f6f1d1'
    ];

    const categories = {
      Bricks: [], Plates: [], Tiles: [], Slopes: [], Technic: [], Minifig: []
    };
    const makeRect = (name,w,d,h,type='brick',opts={}) => ({name,w,d,h,type,...opts});
    for (let s=1; s<=16; s++) {
      categories.Bricks.push(makeRect(`Brick ${s}x1`, s,1,3,'brick'));
      if (s>1) categories.Bricks.push(makeRect(`Brick 1x${s}`,1,s,3,'brick'));
      categories.Plates.push(makeRect(`Plate ${s}x1`, s,1,1,'plate'));
      if (s>1) categories.Plates.push(makeRect(`Plate 1x${s}`,1,s,1,'plate'));
      categories.Tiles.push(makeRect(`Tile ${s}x1`, s,1,1,'tile',{topStuds:false}));
      if (s>1) categories.Tiles.push(makeRect(`Tile 1x${s}`,1,s,1,'tile',{topStuds:false}));
    }
    [2,3,4,6,8,10,12,16].forEach(n=>{
      categories.Bricks.push(makeRect(`Brick ${n}x${n}`,n,n,3,'brick'));
      categories.Plates.push(makeRect(`Plate ${n}x${n}`,n,n,1,'plate'));
      categories.Tiles.push(makeRect(`Tile ${n}x${n}`,n,n,1,'tile',{topStuds:false}));
    });
    categories.Slopes.push(makeRect('Slope 2x2',2,2,3,'slope'));
    categories.Slopes.push(makeRect('Slope 2x3',2,3,3,'slope'));
    categories.Slopes.push(makeRect('Slope 3x2',3,2,3,'slope'));
    categories.Technic.push(makeRect('Technic Brick 1x4',1,4,3,'technic',{holes:true}));
    categories.Technic.push(makeRect('Technic Beam 1x8',1,8,1,'technic',{holes:true,topStuds:false}));
    categories.Minifig.push({name:'Minifig Legs',w:1,d:1,h:2,type:'minifig'});
    categories.Minifig.push({name:'Minifig Torso',w:1,d:1,h:2,type:'minifig'});
    categories.Minifig.push({name:'Minifig Head',w:.8,d:.8,h:1.2,type:'minifig'});
    categories.Minifig.push({name:'Minifig Hat',w:.9,d:.9,h:.8,type:'minifig',topStuds:false});

    let selectedColor = colors[8];
    let selectedPart = categories.Bricks[0];
    let baseplateSize = 32;
    let gridSnap = true, angleSnap = true, supportCheck = true;
    let ghostRotation = 0;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1020, 35, 120);

    const camera = new THREE.PerspectiveCamera(48, innerWidth/innerHeight, .1, 500);
    camera.position.set(22, 22, 22);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.set(0,3,0);

    scene.add(new THREE.HemisphereLight(0xffffff,0x1e293b,.7));
    const dir = new THREE.DirectionalLight(0xffffff,1.2);
    dir.position.set(18,30,12);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048,2048);
    dir.shadow.camera.left = -40; dir.shadow.camera.right = 40;
    dir.shadow.camera.top = 40; dir.shadow.camera.bottom = -40;
    scene.add(dir);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(300,300), new THREE.MeshStandardMaterial({color:0x0a0f1d, roughness:1, metalness:0}));
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -0.01;
    floor.receiveShadow = true;
    scene.add(floor);

    const gridHelper = new THREE.GridHelper(140, 140, 0x334155, 0x1e293b);
    scene.add(gridHelper);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const buildGroup = new THREE.Group();
    scene.add(buildGroup);

    let baseplate, baseplateTopY;
    let pieces = [];
    let selectedIds = new Set();
    let clipboard = [];
    let undoStack = [], redoStack = [];
    let particles = [];

    const materialFor = (hex)=>new THREE.MeshPhysicalMaterial({ color: hex, roughness:.35, metalness:.05, clearcoat:.65, clearcoatRoughness:.2 });

    function createStudMesh(x,z,y,color,scale=1) {
      const stud = new THREE.Mesh(new THREE.CylinderGeometry(0.24*scale,0.24*scale,0.18*scale,20), materialFor(color));
      stud.position.set(x, y, z);
      stud.castShadow = true;
      return stud;
    }

    function makePieceMesh(def,color) {
      const g = new THREE.Group();
      const ySize = def.h * PLATE;
      let body;
      if (def.type === 'slope') {
        const shape = new THREE.Shape();
        shape.moveTo(-def.w/2,0); shape.lineTo(def.w/2,0); shape.lineTo(def.w/2,ySize); shape.lineTo(-def.w/2,ySize*.15); shape.closePath();
        const ex = new THREE.ExtrudeGeometry(shape,{depth:def.d, bevelEnabled:false});
        ex.translate(0,0,-def.d/2);
        body = new THREE.Mesh(ex, materialFor(color));
      } else if (def.type === 'minifig' && def.name.includes('Head')) {
        body = new THREE.Mesh(new THREE.SphereGeometry(.38,24,24), materialFor(color));
      } else if (def.type === 'minifig' && def.name.includes('Hat')) {
        body = new THREE.Mesh(new THREE.CylinderGeometry(.45,.4,.3,20), materialFor(color));
      } else {
        body = new THREE.Mesh(new THREE.BoxGeometry(def.w, ySize, def.d), materialFor(color));
      }
      body.position.y = ySize/2;
      body.castShadow = true;
      body.receiveShadow = true;
      body.userData.main = true;
      g.add(body);

      if (def.topStuds !== false && def.type !== 'minifig') {
        for (let ix=0; ix<Math.max(1,Math.round(def.w)); ix++) {
          for (let iz=0; iz<Math.max(1,Math.round(def.d)); iz++) {
            const sx = -def.w/2 + 0.5 + ix;
            const sz = -def.d/2 + 0.5 + iz;
            g.add(createStudMesh(sx,sz,ySize+.09,color));
          }
        }
      }
      if (def.type === 'technic' && def.holes) {
        for (let iz=0; iz<def.d; iz++) {
          const hole = new THREE.Mesh(new THREE.TorusGeometry(.18,.05,10,20), new THREE.MeshStandardMaterial({color:0x111111,roughness:.8}));
          hole.rotation.y = Math.PI/2;
          hole.position.set(0, ySize*0.5, -def.d/2+.5+iz);
          g.add(hole);
        }
      }
      return g;
    }

    function updateSelectionVisuals() {
      pieces.forEach(p=>{
        const sel = selectedIds.has(p.id);
        p.mesh.traverse(o=>{ if (o.isMesh && o.userData.main) o.material.emissive = new THREE.Color(sel ? 0x1d4ed8 : 0x000000); });
      });
    }

    function rebuildBaseplate() {
      if (baseplate) scene.remove(baseplate);
      baseplate = new THREE.Group();
      const main = new THREE.Mesh(new THREE.BoxGeometry(baseplateSize, BASE_HEIGHT, baseplateSize), new THREE.MeshPhysicalMaterial({color:0x365314, roughness:.8, clearcoat:.15}));
      main.position.y = BASE_HEIGHT/2;
      main.receiveShadow = true;
      baseplate.add(main);
      for (let x=0;x<baseplateSize;x++) for (let z=0;z<baseplateSize;z++) {
        baseplate.add(createStudMesh(-baseplateSize/2+.5+x, -baseplateSize/2+.5+z, BASE_HEIGHT+.09, '#3f6212', .95));
      }
      baseplateTopY = BASE_HEIGHT;
      scene.add(baseplate);
    }

    function getFootprintCells(def, pos, rot) {
      const w = Math.round(def.w), d = Math.round(def.d);
      const cells = [];
      const rot90 = ((Math.round(rot/(Math.PI/2))%4)+4)%4;
      const rw = rot90 % 2 ? d : w;
      const rd = rot90 % 2 ? w : d;
      const x0 = Math.round(pos.x - rw/2 + 0.5);
      const z0 = Math.round(pos.z - rd/2 + 0.5);
      for (let x=0; x<rw; x++) for (let z=0; z<rd; z++) cells.push({x:x0+x, z:z0+z});
      return { cells, rw, rd, y0:Math.round(pos.y/PLATE), y1:Math.round((pos.y + def.h*PLATE)/PLATE) };
    }

    function intersects(a,b){
      const aSet = new Set(a.cells.map(c=>`${c.x},${c.z}`));
      for (const c of b.cells) if (aSet.has(`${c.x},${c.z}`)) return true;
      return false;
    }

    function canPlace(def,pos,rot,ignoreId=null) {
      const fp = getFootprintCells(def,pos,rot);
      const inBounds = fp.cells.every(c => c.x >= -baseplateSize/2 && c.z >= -baseplateSize/2 && c.x < baseplateSize/2 && c.z < baseplateSize/2);
      if (!inBounds) return {ok:false,msg:'Out of baseplate bounds'};

      for (const p of pieces) {
        if (p.id===ignoreId) continue;
        const pf = getFootprintCells(p.def,p.pos,p.rot);
        const yOverlap = !(fp.y1 <= pf.y0 || fp.y0 >= pf.y1);
        if (yOverlap && intersects(fp,pf)) return {ok:false,msg:'Collision detected'};
      }
      if (!supportCheck) return {ok:true};

      if (Math.abs(pos.y - baseplateTopY) < 1e-4) return {ok:true};
      let supported = false;
      for (const p of pieces) {
        const topY = p.pos.y + p.def.h * PLATE;
        if (Math.abs(topY - pos.y) > 1e-4) continue;
        if (p.def.topStuds === false && p.def.type !== 'technic') continue;
        const pf = getFootprintCells(p.def,p.pos,p.rot);
        if (intersects(fp,pf)) { supported = true; break; }
      }
      return supported ? {ok:true} : {ok:false,msg:'No stud/tube support under part'};
    }

    function addPiece(def, color, pos, rot, options={}) {
      const validation = canPlace(def,pos,rot, options.ignoreId);
      if (!validation.ok) { setHint(validation.msg, true); return null; }
      const mesh = makePieceMesh(def,color);
      mesh.position.copy(pos);
      mesh.rotation.y = rot;
      mesh.userData.pieceId = options.id ?? crypto.randomUUID();
      buildGroup.add(mesh);
      const piece = { id: mesh.userData.pieceId, def, color, pos: pos.clone(), rot, mesh };
      pieces.push(piece);
      if (!options.skipHistory) pushHistory();
      wobble(mesh);
      pingSound();
      return piece;
    }

    function removePiece(id, history=true) {
      const i = pieces.findIndex(p=>p.id===id);
      if (i<0) return;
      const p = pieces[i];
      poof(p.mesh.position.clone(), p.color);
      buildGroup.remove(p.mesh);
      pieces.splice(i,1);
      selectedIds.delete(id);
      if (history) pushHistory();
    }

    function setHint(t,bad=false){ hint.textContent = t; hint.style.borderColor = bad ? 'rgba(239,68,68,.55)' : 'rgba(255,255,255,.12)'; }

    function snap(v,s=1){ return Math.round(v/s)*s; }

    let ghost = makePieceMesh(selectedPart, '#ffffff');
    ghost.traverse(m=>{ if(m.isMesh){ m.material = m.material.clone(); m.material.transparent = true; m.material.opacity=.45; }});
    scene.add(ghost);

    function refreshGhostDef() {
      scene.remove(ghost);
      ghost = makePieceMesh(selectedPart, selectedColor);
      ghost.traverse(m=>{ if(m.isMesh){ m.material = m.material.clone(); m.material.opacity=.45; m.material.transparent=true; }});
      ghost.rotation.y = ghostRotation;
      scene.add(ghost);
    }

    function setGhostAt(pos) {
      ghost.position.copy(pos);
      ghost.rotation.y = ghostRotation;
      const valid = canPlace(selectedPart, pos, ghostRotation);
      ghost.traverse(m=>{ if (m.isMesh) m.material.color.set(valid.ok ? selectedColor : '#ef4444'); });
      setHint(valid.ok ? `${selectedPart.name} ready` : valid.msg, !valid.ok);
    }

    function planeIntersection(event) {
      mouse.x = (event.clientX/innerWidth)*2-1;
      mouse.y = -(event.clientY/innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -baseplateTopY);
      const p = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane,p);
      return p;
    }

    function findHit(event){
      mouse.x = (event.clientX/innerWidth)*2-1;
      mouse.y = -(event.clientY/innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const meshes = pieces.map(p=>p.mesh);
      const hits = raycaster.intersectObjects(meshes,true);
      if (!hits.length) return null;
      let o = hits[0].object;
      while (o && !o.userData.pieceId) o = o.parent;
      return o ? pieces.find(p=>p.id===o.userData.pieceId) : null;
    }

    function desiredPlacement(event) {
      const p = planeIntersection(event);
      let x = p.x, z = p.z;
      if (gridSnap) { x = snap(x, STUD); z = snap(z, STUD); }
      const y = baseplateTopY;
      return new THREE.Vector3(x,y,z);
    }

    function recolorSelection() {
      pieces.forEach(p=>{
        if (!selectedIds.has(p.id)) return;
        p.color = selectedColor;
        buildGroup.remove(p.mesh);
        p.mesh = makePieceMesh(p.def,p.color);
        p.mesh.position.copy(p.pos);
        p.mesh.rotation.y = p.rot;
        p.mesh.userData.pieceId = p.id;
        buildGroup.add(p.mesh);
      });
      pushHistory();
      updateSelectionVisuals();
    }

    function serialize(){
      return {
        baseplateSize,
        pieces: pieces.map(p=>({ id:p.id, def:p.def, color:p.color, pos:p.pos.toArray(), rot:p.rot }))
      };
    }

    function loadState(state, history=false){
      buildGroup.clear(); pieces = []; selectedIds.clear();
      baseplateSize = state.baseplateSize ?? baseplateSize;
      document.getElementById('baseplateSize').value = `${baseplateSize}x${baseplateSize}`;
      rebuildBaseplate();
      for (const p of state.pieces||[]) {
        const mesh = makePieceMesh(p.def,p.color);
        mesh.position.fromArray(p.pos);
        mesh.rotation.y = p.rot;
        mesh.userData.pieceId = p.id;
        buildGroup.add(mesh);
        pieces.push({id:p.id, def:p.def, color:p.color, pos:new THREE.Vector3().fromArray(p.pos), rot:p.rot, mesh});
      }
      if (history) pushHistory();
    }

    function pushHistory() {
      undoStack.push(JSON.stringify(serialize()));
      redoStack.length = 0;
      if (undoStack.length > 3000) undoStack.shift();
    }

    function undo(){
      if (undoStack.length<2) return;
      const cur = undoStack.pop();
      redoStack.push(cur);
      loadState(JSON.parse(undoStack.at(-1)), false);
    }

    function redo(){
      if (!redoStack.length) return;
      const s = redoStack.pop();
      undoStack.push(s);
      loadState(JSON.parse(s), false);
    }

    function pingSound(){
      try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        const ctx = pingSound.ctx || (pingSound.ctx = new Ctx());
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'triangle'; o.frequency.value = 520;
        g.gain.value = .001;
        o.connect(g); g.connect(ctx.destination);
        o.start(); g.gain.exponentialRampToValueAtTime(.08, ctx.currentTime+.01);
        g.gain.exponentialRampToValueAtTime(.0001, ctx.currentTime+.12);
        o.stop(ctx.currentTime+.13);
      } catch {}
      if (navigator.vibrate) navigator.vibrate(12);
    }

    function wobble(mesh){
      mesh.userData.wobble = {t:0};
    }

    function poof(pos,color){
      for(let i=0;i<20;i++){
        const m = new THREE.Mesh(new THREE.SphereGeometry(.06,8,8), new THREE.MeshBasicMaterial({color}));
        m.position.copy(pos);
        scene.add(m);
        particles.push({m, v:new THREE.Vector3((Math.random()-.5)*.16, Math.random()*.2, (Math.random()-.5)*.16), life:1});
      }
    }

    function saveLocal(){
      const slots = JSON.parse(localStorage.getItem('lego_studio_slots')||'[]');
      const name = `Build ${new Date().toLocaleString()}`;
      const thumb = renderer.domElement.toDataURL('image/png');
      slots.unshift({name, thumb, state: serialize()});
      localStorage.setItem('lego_studio_slots', JSON.stringify(slots.slice(0,40)));
      refreshSlots();
      setHint('Saved locally ✅');
    }

    function refreshSlots(){
      const sel = document.getElementById('saveSlots');
      sel.innerHTML = '<option value="">(slot)</option>';
      (JSON.parse(localStorage.getItem('lego_studio_slots')||'[]')).forEach((s,i)=>{
        const o = document.createElement('option'); o.value = i; o.textContent = s.name; sel.appendChild(o);
      });
    }

    function loadTemplate(name){
      const t = [];
      const add=(def,color,x,y,z,r=0)=>t.push({id:crypto.randomUUID(),def,color,pos:[x,y,z],rot:r});
      if(name==='car'){
        add(makeRect('Plate 6x2',6,2,1,'plate'),'#111111',0,baseplateTopY,0);
        add(makeRect('Brick 2x2',2,2,3,'brick'),'#d91f26',-2,baseplateTopY+PLATE,0);
        add(makeRect('Brick 2x2',2,2,3,'brick'),'#d91f26',2,baseplateTopY+PLATE,0);
        add(makeRect('Slope 2x2',2,2,3,'slope'),'#d91f26',0,baseplateTopY+PLATE,1);
      } else if(name==='castle'){
        for(let x=-4;x<=4;x+=2) for(let z=-4;z<=4;z+=2) add(makeRect('Brick 2x2',2,2,3,'brick'),'#cfd2d6',x,baseplateTopY,z);
        add(makeRect('Brick 1x6',1,6,3,'brick'),'#6d6e71',0,baseplateTopY+3*PLATE,-4);
      } else if(name==='spaceship'){
        add(makeRect('Plate 8x2',8,2,1,'plate'),'#ffffff',0,baseplateTopY,0);
        add(makeRect('Slope 3x2',3,2,3,'slope'),'#0055bf',0,baseplateTopY+PLATE,0);
        add(makeRect('Tile 4x1',4,1,1,'tile',{topStuds:false}),'#74c6ad',0,baseplateTopY+4*PLATE,0);
      } else if(name==='robot'){
        add(makeRect('Brick 2x2',2,2,3,'brick'),'#f2cd37',0,baseplateTopY,0);
        add(makeRect('Brick 2x2',2,2,3,'brick'),'#f2cd37',0,baseplateTopY+3*PLATE,0);
        add({name:'Minifig Head',w:.8,d:.8,h:1.2,type:'minifig'},'#f8bbd0',0,baseplateTopY+6*PLATE,0);
      }
      loadState({baseplateSize, pieces:t}, true);
    }

    function rebuildUI() {
      const categorySel = document.getElementById('category');
      categorySel.innerHTML = Object.keys(categories).map(c=>`<option>${c}</option>`).join('');
      categorySel.value = 'Bricks';
      const drawParts=()=>{
        const partGrid=document.getElementById('partGrid'); partGrid.innerHTML='';
        categories[categorySel.value].forEach((def)=>{
          const b=document.createElement('div'); b.className='part-btn'; b.textContent=def.name;
          if(def===selectedPart) b.classList.add('active');
          b.draggable=true;
          b.onclick=()=>{selectedPart=def; refreshGhostDef(); drawParts();};
          b.ondragstart=(e)=>{selectedPart=def; refreshGhostDef(); e.dataTransfer.setData('text/plain',def.name);};
          partGrid.appendChild(b);
        });
      };
      categorySel.onchange=drawParts;
      drawParts();

      const colorGrid = document.getElementById('colorGrid'); colorGrid.innerHTML='';
      colors.forEach(c=>{
        const b=document.createElement('button'); b.className='swatch'+(c===selectedColor?' active':''); b.style.background=c;
        b.onclick=()=>{selectedColor=c; refreshGhostDef(); rebuildUI(); if (selectedIds.size) recolorSelection();};
        colorGrid.appendChild(b);
      });
    }

    function setupEvents() {
      window.addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
      });

      document.getElementById('togglePanel').onclick=()=>document.getElementById('panel').classList.toggle('collapsed');
      document.getElementById('gridSnap').onchange=e=>gridSnap=e.target.checked;
      document.getElementById('angleSnap').onchange=e=>angleSnap=e.target.checked;
      document.getElementById('supportCheck').onchange=e=>supportCheck=e.target.checked;
      document.getElementById('applyBaseplate').onclick=()=>{ baseplateSize=+document.getElementById('baseplateSize').value.split('x')[0]; rebuildBaseplate(); pushHistory(); };
      document.getElementById('clearScene').onclick=()=>{ loadState({baseplateSize,pieces:[]},true); setHint('Scene cleared'); };
      document.getElementById('undo').onclick=undo;
      document.getElementById('redo').onclick=redo;
      document.getElementById('copy').onclick=()=>{
        clipboard = pieces.filter(p=>selectedIds.has(p.id)).map(p=>({def:p.def,color:p.color,pos:p.pos.toArray(),rot:p.rot}));
        setHint(`Copied ${clipboard.length} piece(s)`);
      };
      document.getElementById('paste').onclick=()=>{
        clipboard.forEach(c=> addPiece(c.def,c.color,new THREE.Vector3(c.pos[0]+2,c.pos[1],c.pos[2]+2),c.rot));
      };
      document.getElementById('delete').onclick=()=>{ [...selectedIds].forEach(id=>removePiece(id,false)); pushHistory(); };
      document.querySelectorAll('.tpl').forEach(b=>b.onclick=()=>loadTemplate(b.dataset.template));
      document.getElementById('saveLocal').onclick=saveLocal;
      document.getElementById('loadLocal').onclick=()=>{
        const idx = document.getElementById('saveSlots').value; if(idx==='')return;
        const slots = JSON.parse(localStorage.getItem('lego_studio_slots')||'[]');
        if (slots[idx]) { loadState(slots[idx].state,true); setHint('Loaded slot'); }
      };
      document.getElementById('exportJson').onclick=()=>document.getElementById('ioArea').value = JSON.stringify(serialize(),null,2);
      document.getElementById('importJson').onclick=()=>{
        try { loadState(JSON.parse(document.getElementById('ioArea').value), true); setHint('JSON imported'); }
        catch { setHint('Invalid JSON', true); }
      };
      document.getElementById('customColor').oninput=(e)=>{ selectedColor=e.target.value; refreshGhostDef(); if(selectedIds.size) recolorSelection(); rebuildUI(); };

      let dragSelecting=false, start={x:0,y:0};
      const box = document.getElementById('selectionBox');
      renderer.domElement.addEventListener('pointerdown',(e)=>{
        if (e.button===2) return;
        if (e.shiftKey) {
          dragSelecting=true; start={x:e.clientX,y:e.clientY}; box.style.display='block'; box.style.left=`${start.x}px`; box.style.top=`${start.y}px`; box.style.width='0px'; box.style.height='0px';
          controls.enabled=false;
          return;
        }
        const hit = findHit(e);
        if (hit) {
          if (!e.ctrlKey) selectedIds.clear();
          selectedIds.add(hit.id); updateSelectionVisuals();
        } else {
          if (!e.ctrlKey) selectedIds.clear();
          updateSelectionVisuals();
          const pos = desiredPlacement(e);
          addPiece(selectedPart, selectedColor, pos, ghostRotation);
        }
      });

      renderer.domElement.addEventListener('pointermove',(e)=>{
        setGhostAt(desiredPlacement(e));
        if (!dragSelecting) return;
        const x=Math.min(start.x,e.clientX), y=Math.min(start.y,e.clientY), w=Math.abs(e.clientX-start.x), h=Math.abs(e.clientY-start.y);
        Object.assign(box.style,{left:`${x}px`,top:`${y}px`,width:`${w}px`,height:`${h}px`});
      });

      renderer.domElement.addEventListener('pointerup',(e)=>{
        if(!dragSelecting) return;
        dragSelecting=false; box.style.display='none'; controls.enabled=true;
        const r = box.getBoundingClientRect();
        pieces.forEach(p=>{
          const v = p.mesh.position.clone().project(camera);
          const sx = (v.x*.5+.5)*innerWidth;
          const sy = (-v.y*.5+.5)*innerHeight;
          if (sx>=r.left&&sx<=r.right&&sy>=r.top&&sy<=r.bottom) selectedIds.add(p.id);
        });
        updateSelectionVisuals();
      });

      window.addEventListener('keydown',(e)=>{
        if (e.key.toLowerCase()==='q') { ghostRotation += angleSnap ? Math.PI/2 : Math.PI/12; }
        if (e.key.toLowerCase()==='e') { ghostRotation -= angleSnap ? Math.PI/2 : Math.PI/12; }
        if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z') { e.shiftKey ? redo() : undo(); }
        if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='y') redo();
        if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='c') document.getElementById('copy').click();
        if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='v') document.getElementById('paste').click();
        if (e.key==='Delete' || e.key==='Backspace') document.getElementById('delete').click();
      });

      renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());
      renderer.domElement.addEventListener('dragover', e=>e.preventDefault());
      renderer.domElement.addEventListener('drop', (e)=>{
        e.preventDefault();
        addPiece(selectedPart, selectedColor, desiredPlacement(e), ghostRotation);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      for (const p of pieces) {
        if (p.mesh.userData.wobble) {
          p.mesh.userData.wobble.t += 0.13;
          const t=p.mesh.userData.wobble.t;
          p.mesh.rotation.z = Math.sin(t)*0.025*Math.exp(-t*0.35);
          if (t>18) { p.mesh.rotation.z=0; p.mesh.userData.wobble=null; }
        }
      }
      particles = particles.filter(pr=>{
        pr.life -= .03; if (pr.life<=0) { scene.remove(pr.m); return false; }
        pr.m.position.add(pr.v); pr.v.y -= .004; pr.m.scale.setScalar(pr.life); return true;
      });
      renderer.render(scene,camera);
    }

    rebuildBaseplate();
    rebuildUI();
    refreshSlots();
    setupEvents();
    const initPos = new THREE.Vector3(0, baseplateTopY, 0);
    setGhostAt(initPos);
    pushHistory();
    animate();
  </script>
</body>
</html>
